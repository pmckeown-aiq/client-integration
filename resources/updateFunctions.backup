// fs required for attaching documents
var fs = require('fs');

// fs required for attaching documents
// function to encode file data to base64 encoded string
function base64_encode(file) {
    // read binary data
    var attachment = fs.readFileSync(file);
    // convert binary data to base64 encoded string
    return new Buffer(attachment).toString('base64');
}

// required for GetTransactionsByExternalReference
var _ = require('lodash');

module.exports = {
  CheckUniqueInvoiceByExternalReference: function(v) {
    // Use GetTransactionsByExternalReference - so can check by customer/supplier
    var query = {};
    query.ExternalReference = v.ExternalReference;
    if ( typeof v.GetTransactionsTransactionType !== 'undefined' ) { 
      query.TypesFilter = [];
      query.TypesFilter.push(v.GetTransactionsTransactionType);
    }
    if ( typeof v.AccountID !== 'undefined' ) { 
      query.AccountIDsFilter = [];
      query.AccountIDsFilter.push(v.AccountID);
    }
    console.log('GetTransactions query is ' + JSON.stringify(query));
    return new Promise(function(resolve, reject) {
      console.log('Running CheckUniqueInvoiceByExternalReference for ' + v.ExternalReference + ' with flag ' + v.uniqueExternalReferences);
      if (v.uniqueExternalReferences == true ) {
        Promise.all([aiq.GetTransactionsByExternalReference({query: query})])
          .then((result) => {
            console.log('Result from GetTransactionsByExternalReference ' + v.ExternalReference + ' ' + JSON.stringify(result[0]));
            if (result[0].Status == 'Success' ) {
              if (result[0].Result) {
                if (result[0].Result.WSTransactionSummary) {
                  if ( result[0].Result.WSTransactionSummary.length > 0 ) {
                    console.log('going to reject ' );
                    updateStageStatus = {"stage": "CheckUniqueInvoiceByExternalReference", "status": false, "serverStatus" : "Error", "error" : "TransactionExists", "message" : "Already exists." + result[0].Result.WSTransactionSummary.length + " transaction(s) exist with that reference. Transactions must have unique external references." };
                    v.updateStageStatus.push(updateStageStatus);
                    console.log('UpdateStageStatuse ' + v.updateStageStatus);
                    console.log("going to reject " + JSON.stringify(v.updateStageStatus));
                    reject(v);
                  } else {
                    updateStageStatus = {"stage" : "CheckUniqueInvoiceByExternalReference", "status": true, "serverStatus" : result[0].Status, "message" : "Passed validation that external reference is unique" };
        	    v.updateStageStatus.push(updateStageStatus);
                    console.log('UpdateStageStatuse ' + v.updateStageStatus);
                    console.log('UpdateStageStatuse ' + updateStageStatus);
                    resolve(v);
                  }
                }
              } else {
                console.log("was a success but null Invoice returned");
                updateStageStatus = {"stage" : "CheckUniqueInvoiceByExternalReference", "status": true, "serverStatus" :result[0].Status, "message" : "Passed validation that external reference is unique" };
                v.updateStageStatus.push(updateStageStatus);
                    console.log('UpdateStageStatuse ' + v.updateStageStatus);
                resolve(v);
              }
            } else {
              updateStageStatus = {"stage" : "CheckUniqueInvoiceByExternalReference", "status": true, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : "Check external reference is unique was not a success" };
              v.updateStageStatus.push(updateStageStatus);
                    console.log('UpdateStageStatuse ' + v.updateStageStatus);
              resolve(v);
            }
          }, function() {
            console.log("REJECT PROMISE FOR THE CheckUniqueInvoiceByExternalReference - send it back to the client");
          });
      } else {
        // Don't need to ensure unique external references
        resolve(v);
      }
    }, function() {
      console.log('REJECT PROMISE FOR THE CheckUniqueInvoiceByExternalReference - send it back to the client');
    });
  },	  
  GetNewInvoice: function(v) {
    return new Promise(function(resolve, reject) {
    console.log('GetNewInvoice comes with ' + JSON.stringify(v));
    Promise.all([aiq[transactionTemplate]({[templatingType]: v[templatingValue] })])
      .then((result) => {
        console.log('1 Got result from Promise.all ' + JSON.stringify(result));
        result = result[0].Result;
        console.log('2 Got result[0].Result from Promise.all ' + JSON.stringify(result));
        // r is now a template - but not a complete template! It is missing a few required fields ... so we add them 
        result.OrderNumber = '';
        result.PaymentMethodID = '';
        result.AreaID = '';
        result.Contact = '';
        result.Notes = '';
        result.DepartmentID = '';
        // AccountBranchID is a number - not the customer code
        result.AccountBranchID = result.AccountID
        delete v.AccountID_getFromApiValue;
        delete v.$$hashKey;
        console.log('3 Got result.Result from Promise.all' + JSON.stringify(result));
        // Remove the angular has key from the data we are to send
        for (var i=0;i<v.lines.length;i++) {
          delete v.lines[i].$$hashKey;
          // Remove warnings added to line when amounts calculated
          // only needed for logging
          delete v.lines[i].isWarning;
          if ( typeof v.lines[i].TaxAmount == "undefined" ) {
            console.log('We have no TaxAmount - assume 0');
            v.lines[i].TaxAmount = 0;
          }
          if ( typeof v.lines[i].DiscountRate == "undefined" ) {
            console.log('We have no DiscountRate - assume 0');
            v.lines[i].DiscountRate = 0;
          } 
          if ( typeof v.lines[i].ActualPrice == "undefined" ) {
            v.lines[i].ActualPrice = (v.lines[i].StockItemPrice * (1 - v.lines[i].DiscountRate))
          }
          // Notes must be chopped to 250 characters (limit in DB)
          if ( typeof v.lines[i].Notes !== 'undefined' ) {
            v.lines[i].Notes = v.lines[i].Notes.substring(0,250);
          }
          v.lines[i].GrossAmount = (v.lines[i].NetAmount*1) + (v.lines[i].TaxAmount*1);
          console.log('IS ' + v.ExternalReference + ' negative: ' + v.negativeAmounts );
          if ( v.negativeAmounts == true ) {
            // make the amounts positive (as they are negative - or should be!) 
            v.lines[i].StockItemPrice =  v.lines[i].StockItemPrice * -1
            v.lines[i].NetAmount =  v.lines[i].NetAmount * -1
            v.lines[i].TaxAmount =  v.lines[i].TaxAmount * -1
            v.lines[i].GrossAmount =  v.lines[i].GrossAmount * -1
            v.lines[i].ActualPrice =  v.lines[i].ActualPrice * -1
          }
        };
        console.log('Lines are ' + JSON.stringify(v.lines));
        // lines must become lines.invoiceLine(its the way the SOAP API expects it ... also needs to be "Lines"  on "result"
        var tempLines = { "InvoiceLine" : v.lines };
        delete v.lines;
        v.Lines = tempLines;
        // Notes must be chopped to 250 characters (limit in DB)
        if ( typeof v.Notes !== 'undefined' ) {
          v.Notes = v.Notes.substring(0,250);
        }
        //console.log('Final Invoice is ' + JSON.stringify(v));
        // loop through the transaction object (v) to set the supplied value in the JSON document to the result from GetNewSalesInvoice
        // May not have header amoungt fields ... can supply as 0 and leave AIQ to work out
        if ( typeof v.NetAmount == "undefined" ) {
          v.NetAmount = 0;
        }
        if ( typeof v.TaxAmount == "undefined" ) {
          v.TaxAmount = 0;
        }
        v.GrossAmount = (v.NetAmount*1) + (v.TaxAmount*1);
        // Transpose v into result (update the SOAP invoice
        for (var name in v) {
          if ( name != "transactionType" ) {
            if ( name != "uniqueExternalReferences" ) {
              if ( name != "transactionTemplate" ) {
                console.log(name + ' has value ' + v[name]);
                // and apply to result the corresponding value in feed transactions (referenced as v)
                result[name] = v[name];
              }
            }
          }
        };
        console.log('AIQ Invoice is transposed to result complete');
        updateStageStatus = {"stage" : "GetNewInvoice", "status": true, "serverStatus" : "Success", "message" : "Template complete"};
        result.updateStageStatus.push(updateStageStatus);
        resolve(result);
      })
      .catch(function(err) { // SOAP error on Save Invoice
        console.log('SOAP Error' + JSON.stringify(err));
        updateStageStatus = { "stage" : "GetNewInvoice", "status": false, "serverStatus" : v.Status, "message" : "Failed to complete saveInvoice", "error": JSON.stringify(err)};
        v.updateStageStatus.push(updateStageStatus);
                    console.log('UpdateStageStatuse ' + v.updateStageStatus);
        reject(v);
      });
    });
  },
  SaveInvoiceGetBackInvoiceID: function(v) {
    return new Promise(function(resolve, reject) {
    console.log('in SaveInvoiceGetBackInvoiceID' + JSON.stringify(v));
    Promise.all([aiq.SaveInvoiceGetBackInvoiceID({invoice: v, create: true})])
      .then((result) => {
        console.log('Resolve SaveInvoiceGetBackInvoiceID' + JSON.stringify(result[0].Status)); 
        if ( result[0].Status == "Created" ) {
          v.transactionID = result[0].invoiceID;
          updateStageStatus = { "stage" : "SaveInvoiceGetBackInvoiceID", "status": true, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : "Transaction Saved", "transactionID" : v.transactionID };
          v.updateStageStatus.push(updateStageStatus);
                    console.log('UpdateStageStatuse ' + v.updateStageStatus);
          resolve(v);
        } else {
          updateStageStatus = { "stage" : "SaveInvoiceGetBackInvoiceID", "status": false, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : "Transaction Save Failed: " + result[0].ErrorCode};
          v.updateStageStatus.push(updateStageStatus);
                    console.log('UpdateStageStatuse ' + v.updateStageStatus);
          reject(v);
        }
      })
      .catch(function(err) { // SOAP error on Save Invoice
        console.log("SOAP Error" + JSON.stringify(err));
        updateStageStatus = { "stage" : "SaveInvoiceGetBackInvoiceID", "status": false, "serverStatus" : v.Status, "message" : "Failed to complete SaveInvoiceGetBackInvoiceID", "error": JSON.stringify(err)};
        v.updateStageStatus.push(updateStageStatus);
                    console.log('UpdateStageStatuse ' + v.updateStageStatus);
        reject(v);
      });
    });
  },
  PostInvoiceGetBackTransactionID: function(v) {
    return new Promise(function(resolve, reject) {
    console.log('in postInvoice' + JSON.stringify(v));
    console.log('CHECK IF NEED TO POST ' + v.updateStageStatus.status + ' ' + v.Status);
    //if ( v.updateStageStatus.status == 'Created' && v.Status == 'Posted' ) { // the invoice should be posted - cant do when save it, need to post it using the transactionID
    if ( v.Status == 'Posted' ) { // the invoice should be posted - cant do when save it, need to post it using the transactionID
    console.log('GOING TO POST ' +  v.updateStageStatus.transactionID );
      Promise.all([aiq.PostInvoiceGetBackTransactionID({ invoiceID: v.transactionID })])
        .then((result) => {
          updateStageStatus = { "stage" : "PostInvoiceGetBackTransactionID", "status": false, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : "Transaction Posted", "transactionID": v.transactionID  };
          v.updateStageStatus.push(updateStageStatus);
          if ( result[0].status = "Created" ) {
            console.log('Resolve PostInvoiceGetBackTransactionID' + JSON.stringify(v.updateStageStatus)); 
            resolve(v);
          } else {
            reject(v);
          }
          resolve(v);
        }).catch(function(err) { // SOAP error on Post Invoice
          console.log('SOAP Error' + JSON.stringify(result));
          updateStageStatus = { "stage" : "PostInvoiceGetBackTransactionID", "status": false, "serverStatus" : v.Status, "message" : "Failed.", "error": JSON.stringify(err), "transactionID": v.transactionID  };
          v.updateStageStatus.push(updateStageStatus);
          reject(v);
      });
    } else {
          console.log('Resolve postInvoice - No Need to Post Invoice');
          resolve(v);
    }
    })
    .catch(function(err) { // SOAP error on Post Invoice
      console.log('SOAP Error' + JSON.stringify(err));
      updateStageStatus = { "stage" : "postInvoice", "status": true, "serverStatus" : v.Status, "message" : "Failed.", "error": JSON.stringify(err), "transactionID": v.transactionID  };
      v.updateStageStatus.push(updateStageStatus);
      console.log(JSON.stringify(v.updateStageStatus));
      resolve(v);
    });
  },
  AttachDocument: function(v) {
    return new Promise(function(resolve, reject) {
    console.log('in attachDocument' + JSON.stringify(v));
    console.log('transationID ' + JSON.stringify(v.transactionID));
    if ( typeof v.AttachDocument !== 'undefined' ) {
      var document = { "Header": {"MasterType": "SalesInvoice", "MasterID": v.transactionID, "Filename": v.ExternalReference + ".xlsx" } }
      console.log('Going to attach document ' + v.AttachDocument);
      console.log('transationID ' + JSON.stringify(document));
      document.Content = {};
      document.Content.Content = base64_encode(v.AttachDocument);
      document.Content.Comments = 'Attached by data import';
      console.log('transationID ' + JSON.stringify(document));
      Promise.all([aiq.AttachDocument({ "document": document })])
        .then((result) => {
          updateStageStatus = { "stage" : "AttachDocument", "status": true, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : "Attach document complete", "transactionID" : v.transactionID };
          v.updateStageStatus.push(updateStageStatus);
          console.log('Resolve attachDocument' + JSON.stringify(v)); 
          resolve(v);
        })
        .catch(function(err) { // SOAP error on Save Invoice
          console.log('SOAP Error' + JSON.stringify(err));
          updateStageStatus = { "stage" : "AttachDocument", "status": false, "serverStatus" : v.Status, "message" : "Failed to complete AttachDocument.", "error": JSON.stringify(err) };
          v.updateStageStatus.push(updateStageStatus);
          reject(v);
        });
    } else {
      console.log('No AttachDocument property - no attaching!');
      resolve(v);
    }
    });
  },
  writeBack: function(v) {
    return new Promise(function(resolve, reject) {
            if ( opts.writeBackRules) {
              if ( opts.writeBackRules.allowed == true ) {
                console.log('calling writeBack function ' + opts.writeBackRules.writeBackFunction)
                this.writeBack = new writeBack(this);
                try {
                  this.writeBack[opts.writeBackRules.writeBackFunction](opts, v, function(err, wroteBack) {
                    if (err) { 
  	              console.log('Error returned ' + JSON.stringify(err))
                      process.send({ "error" : "error writing back data " , "data": err });   
                              return err;
                    };
                            process.send({ wroteBack }); 
                  })
                } catch (err) {
                  console.log('catch called ' + err);
                         process.send({ "error" : "error writing back data " + err }); 
                }
                wroteBack.transactionRef = v.ExternalReference;
                console.log('WroteBack Result: ' + JSON.stringify(wroeBack));
                process.send({ wroteBack }); 
              }
           }
    });
  },
  SaveSalesReceiptGetBackTransactionID: function(v) {
    return new Promise(function(resolve, reject) {
    console.log('in SaveSalesReceiptGetBackTransactionID' + JSON.stringify(v));
    Promise.all([aiq.SaveSalesReceiptGetBackTransactionID({ 'salesReceipt': v })])
      .then((result) => {
        console.log('Resolve SaveSalesReceiptGetBackTransactionID' + JSON.stringify(result[0])); 
        console.log('Resolve SaveSalesReceiptGetBackTransactionID' + JSON.stringify(v)); 
        if ( result[0].status = "Created" ) {
          // FOR EPIC - Description on the receipt is the External Reference ,....
          v.ExternalReference = v.Description;
          v.transactionID = result[0].transactionID;
          updateStageStatus = { "stage" : "SaveSalesReceiptGetBackTransactionID", "status": true, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : "Transaction Saved", "transactionID" : v.transactionID };
          v.updateStageStatus.push(updateStageStatus);
          resolve(v);
        } else {
          updateStageStatus = { "stage" : "SaveSalesReceiptGetBackTransactionID", "status": false, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : "Transaction Save Failed: " + result[0].ErrorCode};
          v.updateStageStatus.push(updateStageStatus);
          reject(v);
        }
      })
      .catch(function(err) { // SOAP error on Save Invoice
        console.log('SOAP Error' + JSON.stringify(err));
        updateStageStatus = { "stage" : "SaveSalesReceiptGetBackTransactionID", "status": false, "serverStatus" : v.Status, "message" : "Failed to complete SaveSalesReceiptGetBackTransactionID", "error": JSON.stringify(err)};
        v.updateStageStatus.push(updateStageStatus);
        reject(v);
      });
    });
  },
  GetInvoicesByExternalReference: function(v) {
    // GetInvoicesByExternalReference returns two objects on resolve - v (the object passed when called) and an array of invoices matched to the v.ExternalReference
    return new Promise(function(resolve, reject) {
    console.log('in GetInvoicesByExternalReference' + JSON.stringify(v));
    Promise.all([aiq.GetInvoicesByExternalReference({ externalReference: v.ExternalReference })])
      .then((result) => {
        console.log('Resolve GetInvoicesByExternalReference' + JSON.stringify(result[0])); 
        console.log('Check Result null ' + result[0]);
        if (result[0].Result) {
          console.log('Check Result - ' + result[0].Result );
          if (result[0].Result.Invoice) {
            if ( result[0].Result.Invoice.length > 0 ) {
              console.log('GetInvoicesByExternalReference returned:' + JSON.stringify(result[0].Result.Invoice.length));
              // fetch out the transaction ID's
              var transactionIDs = _.map(result[0].Result.Invoice, 'InvoiceID');
              updateStageStatus = { "stage" : "GetInvoicesByExternalReference", "status": true, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : result[0].Result.Invoice.length + " transactions returned", "transactionID" : transactionIDs };
              v.updateStageStatus.push(updateStageStatus);
              console.log('resolve GetInvoicesByExternalReference ' + JSON.stringify(v) + ' as v and as i ' + JSON.stringify(result[0].Result.Invoice));
              resolve({ "fetchedVia": v, "fetchedInvoices": result[0].Result.Invoice});
            }
          }
        } else {
          console.log('Does not mean failed' + JSON.stringify(result[0]));
          if ( result[0].Status == "Success" ) {
            console.log('It was a success');
            updateStageStatus = { "stage" : "GetInvoicesByExternalReference", "status": true, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : "Get Invoices Found No Invoices with External Reference: " + v.ExternalReference, "transactionID" : []};
            v.updateStageStatus.push(updateStageStatus);
            // return an empty invoice array ...
            resolve({ "fetchedVia": v, "fetchedInvoices": []});
          } else {
            updateStageStatus = { "stage" : "GetInvoicesByExternalReference", "status": false, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : "Get Invoices Failed: " + result[0].ErrorCode};
            v.updateStageStatus.push(updateStageStatus);
            reject(v);
          } 
        }
      })
      .catch(function(err) { // SOAP error on Save Invoice
        console.log('SOAP Error' + JSON.stringify(err));
        updateStageStatus = { "stage" : "GetInvoicesByExternalReference", "status": false, "serverStatus" : v.Status, "message" : "Failed to complete GetInvoicesByExternalReference", "error": JSON.stringify(err)};
        v.updateStageStatus.push(updateStageStatus);
        reject(v);
      });
    });
  },
  GetTransactionsByExternalReference: function(v) {
    // GetTransactionsByExternalReference returns two objects on resolve - v (the object passed when called) and an array of invoices matched to the v.ExternalReference
    return new Promise(function(resolve, reject) {
    console.log('in GetTransactionsByExternalReference' + JSON.stringify(v));
    var query = {};
    query.ExternalReference = v.ExternalReference;
    if ( typeof v.GetTransactionsTransactionType !== 'undefined' ) { 
      query.TypesFilter = [];
      query.TypesFilter.push(v.GetTransactionsTransactionType);
    }
    if ( typeof v.AccountID !== 'undefined' ) { 
      query.AccountIDsFilter = [];
      query.AccountIDsFilter.push(v.AccountID);
    }
    console.log('GetTransactions query is ' + JSON.stringify(query));
    Promise.all([aiq.GetTransactionsByExternalReference({ "query" : query })])
      .then((result) => {
        console.log('Resolve GetTransactionsByExternalReference' + JSON.stringify(result[0])); 
        console.log('Check Result null ' + result[0]);
        if (result[0].Result) {
          if (result[0].Result.WSTransactionSummary) {
            console.log('Check Result - ' + JSON.stringify(result[0].Result.WSTransactionSummary));
            if ( result[0].Result.WSTransactionSummary.length > 0 ) {
              var transactionIDs = _.map(result[0].Result.WSTransactionSummary, 'TransactionID');
	
              updateStageStatus = { "stage" : "GetTransactionsByExternalReference", "status": true, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : result[0].Result.WSTransactionSummary.length + " transactions returned", "transactionID" : transactionIDs };
              v.updateStageStatus.push(updateStageStatus);
              console.log('resolve GetTransactionsByExternalReference ' + JSON.stringify(v) + ' as v and as i ' + JSON.stringify(result[0].Result.WSTransactionSummary));
              resolve({ "fetchedVia": v, "fetchedTransactions": result[0].Result.WSTransactionSummary});
            }
          }
        } else {
          console.log('Does not mean failed' + JSON.stringify(result[0]));
          if ( result[0].Status == "Success" ) {
            console.log('It was a success');
            updateStageStatus = { "stage" : "GetTransactionsByExternalReference", "status": true, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : "Get Transactions Found No Transactions with External Reference: " + v.ExternalReference, "transactionID" : []};
            v.updateStageStatus.push(updateStageStatus);
            // return an empty invoice array ...
            resolve({ "fetchedVia": v, "fetchedTransactions": []});
          } else {
            updateStageStatus = { "stage" : "GetTransactionsByExternalReference", "status": false, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : "Get Transactions Failed: " + result[0].ErrorCode};
            v.updateStageStatus.push(updateStageStatus);
            reject(v);
          } 
        }
      })
      .catch(function(err) { // SOAP error on Save Invoice
        console.log('SOAP Error' + JSON.stringify(err));
        updateStageStatus = { "stage" : "GetTransactionsByExternalReference", "status": false, "serverStatus" : v.Status, "message" : "Failed to complete GetTransactionsByExternalReference", "error": JSON.stringify(err)};
        v.updateStageStatus.push(updateStageStatus);
        reject(v);
      });
    });
  },
  GetCustomer: function(v) {
    // GetCustomer - based on a invoice with CustomerCode - get AccountID
    return new Promise(function(resolve, reject) {
    console.log('in GetCustomer' + JSON.stringify(v));
    Promise.all([aiq.GetCustomer({ customerCode: v.CustomerCode })])
      .then((result) => {
        console.log('Resolve GetCustomer' + JSON.stringify(result[0])); 
        if ( result[0].Status == "Success" ) {
          if (result[0].Result) {
            console.log('Check Result - ' + JSON.stringify(result[0].Result));
            if (result[0].Result.AccountID) {
              console.log('GetCustomer returned:' + JSON.stringify(result[0].Result.AccountID));
              // fetch out the transaction ID's
              v.AccountID = result[0].Result.AccountID ;
              updateStageStatus = { "stage" : "GetCustomer", "status": true, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : "Fetched AccountID for Customer Code " + v.CustomerCode};
              v.updateStageStatus.push(updateStageStatus);
              resolve(v);
            }
          }
        } else {
          updateStageStatus = { "stage" : "GetCustomer", "status": false, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : "Get Invoices Failed: " + result[0].ErrorCode};
          v.updateStageStatus.push(updateStageStatus);
          reject(v);
        }
      })
      .catch(function(err) { // SOAP error on Save Invoice
        console.log('SOAP Error' + JSON.stringify(err));
        updateStageStatus = { "stage" : "GetCustomer", "status": false, "serverStatus" : v.Status, "message" : "Failed to complete GetCustomer", "error": JSON.stringify(err)};
        v.updateStageStatus.push(updateStageStatus);
        reject(v);
      });
    });
  },
  // AllocateTransactions expects two items to be passed to it - v (a payment or receipt) and i - an array of invoices 
  // but promises only return/accept 1 argument so as v: { "fetchedVia": v, "fetchedInvoices": [invoiceArray]}
  AllocateTransactions: function(v) {
    return new Promise(function(resolve, reject) {
      var invoices = v.fetchedTransactions;
      var payment = v.fetchedVia;
      console.log('in AllocateTransactions invoices' + JSON.stringify(invoices));
      console.log('in AllocateTransactions payment' + JSON.stringify(payment));
      if ( invoices.length > 0 ) { // have invoices and length of invoices is greater than 0 - we have invoices
        if ( invoices.length == 1 ) { // have invoices and length of invoices is greater than 0 - we have invoices
          myAllocation = {};
          myAllocation.transactionID_1 =  invoices[0].TransactionID;
          myAllocation.transactionID_2 =  payment.transactionID;
          myAllocation.allocationReference = payment.ExternalReference;
          myAllocation.allocationAmount = payment.PaymentAmount;
          myAllocation.allocationDate = payment.PaymentDate;
          console.log('GOING TO ALLOCATE ' + JSON.stringify(myAllocation))
          Promise.all([aiq.AllocateTransactions(myAllocation)])
            .then((result) => {
              console.log('Check Result AllocateTransactionsResult ' + JSON.stringify(result[0]));
              if (result[0] ) {
                if (result[0].Status == 'Success' ) {
                    updateStageStatus = { "stage" : "AllocateTransactions", "status": true, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : "Allocatrion Complete" };
                    payment.updateStageStatus.push(updateStageStatus);
                    resolve(payment);
                } else {
                  updateStageStatus = { "stage" : "AllocateTransactions", "status": false, "serverStatus" : result[0].Status, "error" : result[0].ErrorMessage, "message" : "Allocation Failed: " + result[0].ErrorCode};
                  payment.updateStageStatus.push(updateStageStatus);
                  reject(payment);
                } 
              }
            })
            .catch(function(err) { // SOAP error on allocation
              console.log('SOAP Error' + JSON.stringify(err));
              updateStageStatus = { "stage" : "AllocateTransactions", "status": false, "serverStatus" : payment.Status, "message" : "Failed to complete AllocateTransactions", "error": JSON.stringify(err)};
              payment.updateStageStatus.push(updateStageStatus);
              reject(payment);
            });
        } else {
          // Not sure yet what to do when more than one invoice
          updateStageStatus = { "stage" : "AllocateTransactions", "status": true, "serverStatus" : "NoInvoices", "error" : "", "message" : "Allocation had more than 1 invoice to allocate " + payment.ExternalReference + " to. Not yet supported."};
          payment.updateStageStatus.push(updateStageStatus);
          resolve(payment);
        } 
      } else { // i was not there or had a length of 0 - no invoices
      // Just send it back ... not an error just nothing to do ...
        updateStageStatus = { "stage" : "AllocateTransactions", "status": true, "serverStatus" : "NoInvoices", "error" : "", "message" : "Allocation had no invoices to allocate " + payment.ExternalReference + " to."};
        payment.updateStageStatus.push(updateStageStatus);
        resolve(payment);
      }
    });
  }
}
